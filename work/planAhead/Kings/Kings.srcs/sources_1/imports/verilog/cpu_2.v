/*
   This file was generated automatically by the Mojo IDE version B1.3.3.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module cpu_2 (
    input clk,
    input rst,
    output reg lcdWrite,
    output reg attributeWrite,
    input button0,
    input button1,
    output reg [7:0] led0,
    output reg [7:0] led1,
    output reg [7:0] led2,
    output reg [5:0] display_driver,
    output reg [4:0] attr1,
    output reg [4:0] attr2,
    output reg [4:0] attr3,
    output reg [4:0] attr4,
    output reg [7:0] status
  );
  
  
  
  reg [135:0] M_reg_d, M_reg_q = 1'h0;
  reg [24:0] M_delaycounter_d, M_delaycounter_q = 1'h0;
  reg [27:0] M_harddelaycounter_d, M_harddelaycounter_q = 1'h0;
  reg [49:0] M_qnindexReg_d, M_qnindexReg_q = 1'h0;
  reg [0:0] M_difficulty_d, M_difficulty_q = 1'h0;
  reg [12:0] M_lcddelaycounter_d, M_lcddelaycounter_q = 1'h0;
  wire [6-1:0] M_question_index_chooser_out;
  reg [1-1:0] M_question_index_chooser_enable;
  question_index_chooser_10 question_index_chooser (
    .clk(clk),
    .rst(rst),
    .enable(M_question_index_chooser_enable),
    .out(M_question_index_chooser_out)
  );
  
  wire [1-1:0] M_edge_detector0_out;
  reg [1-1:0] M_edge_detector0_in;
  falling_edge_detector_11 edge_detector0 (
    .clk(clk),
    .in(M_edge_detector0_in),
    .out(M_edge_detector0_out)
  );
  wire [1-1:0] M_edge_detector1_out;
  reg [1-1:0] M_edge_detector1_in;
  falling_edge_detector_11 edge_detector1 (
    .clk(clk),
    .in(M_edge_detector1_in),
    .out(M_edge_detector1_out)
  );
  wire [1-1:0] M_button_cond0_out;
  reg [1-1:0] M_button_cond0_in;
  button_conditioner_13 button_cond0 (
    .clk(clk),
    .in(M_button_cond0_in),
    .out(M_button_cond0_out)
  );
  wire [1-1:0] M_button_cond1_out;
  reg [1-1:0] M_button_cond1_in;
  button_conditioner_13 button_cond1 (
    .clk(clk),
    .in(M_button_cond1_in),
    .out(M_button_cond1_out)
  );
  
  wire [17-1:0] M_instRom_inst;
  reg [8-1:0] M_instRom_address;
  instRom_15 instRom (
    .address(M_instRom_address),
    .inst(M_instRom_inst)
  );
  
  wire [5-1:0] M_effectRom_eff;
  reg [8-1:0] M_effectRom_address;
  attEffectRom_16 effectRom (
    .address(M_effectRom_address),
    .eff(M_effectRom_eff)
  );
  
  reg [4:0] op;
  
  reg [3:0] arg1;
  
  reg [3:0] arg2;
  
  reg [3:0] dest;
  
  reg [7:0] constant;
  
  reg harddelaycounterMSB;
  
  reg difficultysig;
  
  always @* begin
    M_delaycounter_d = M_delaycounter_q;
    M_reg_d = M_reg_q;
    M_qnindexReg_d = M_qnindexReg_q;
    M_difficulty_d = M_difficulty_q;
    M_lcddelaycounter_d = M_lcddelaycounter_q;
    M_harddelaycounter_d = M_harddelaycounter_q;
    
    led0 = M_reg_q[0+7-:8];
    led1 = M_reg_q[64+7-:8];
    led2 = M_reg_q[128+7-:8];
    lcdWrite = 1'h0;
    attributeWrite = 1'h0;
    M_effectRom_address = 1'h0;
    M_instRom_address = M_reg_q[128+7-:8];
    M_reg_d[128+7-:8] = M_reg_q[128+7-:8] + 1'h1;
    M_reg_d[120+7-:8] = 8'h00;
    display_driver = M_reg_q[112+0+5-:6];
    op = M_instRom_inst[12+4-:5];
    dest = M_instRom_inst[8+3-:4];
    arg1 = M_instRom_inst[4+3-:4];
    arg2 = M_instRom_inst[0+3-:4];
    constant = M_instRom_inst[0+7-:8];
    harddelaycounterMSB = M_harddelaycounter_q[27+0-:1];
    M_button_cond0_in = button0;
    M_button_cond1_in = button1;
    M_edge_detector0_in = M_button_cond0_out;
    M_edge_detector1_in = M_button_cond1_out;
    M_question_index_chooser_enable = 1'h0;
    attr1 = M_reg_q[96+0+4-:5];
    attr2 = M_reg_q[88+0+4-:5];
    attr3 = M_reg_q[80+0+4-:5];
    attr4 = M_reg_q[72+0+4-:5];
    difficultysig = M_difficulty_q;
    status = M_reg_q[48+7-:8];
    
    case (op)
      5'h03: begin
        M_reg_d[(dest)*8+7-:8] = constant;
      end
      5'h04: begin
        M_reg_d[(dest)*8+7-:8] = M_reg_q[(arg1)*8+7-:8] < M_reg_q[(arg2)*8+7-:8];
      end
      5'h05: begin
        M_reg_d[(dest)*8+7-:8] = M_reg_q[(arg1)*8+7-:8] == M_reg_q[(arg2)*8+7-:8];
      end
      5'h06: begin
        if (M_reg_q[(dest)*8+7-:8] == 8'h00) begin
          M_reg_d[128+7-:8] = constant;
        end
      end
      5'h07: begin
        if (M_reg_q[(dest)*8+7-:8] != 8'h00) begin
          M_reg_d[128+7-:8] = constant;
        end
      end
      5'h08: begin
        M_reg_d[(dest)*8+7-:8] = M_reg_q[(arg1)*8+7-:8] + M_reg_q[(arg2)*8+7-:8];
      end
      5'h09: begin
        M_reg_d[(dest)*8+7-:8] = M_reg_q[(arg1)*8+7-:8] - M_reg_q[(arg2)*8+7-:8];
      end
      5'h0a: begin
        M_reg_d[(dest)*8+7-:8] = M_reg_q[(arg1)*8+7-:8] << M_reg_q[(arg2)*8+7-:8];
      end
      5'h0b: begin
        M_reg_d[(dest)*8+7-:8] = M_reg_q[(arg1)*8+7-:8] >> M_reg_q[(arg2)*8+7-:8];
      end
      5'h0c: begin
        M_reg_d[(dest)*8+7-:8] = M_reg_q[(arg1)*8+7-:8] & M_reg_q[(arg2)*8+7-:8];
      end
      5'h0d: begin
        M_reg_d[(dest)*8+7-:8] = M_reg_q[(arg1)*8+7-:8] | M_reg_q[(arg2)*8+7-:8];
      end
      5'h0e: begin
        M_reg_d[(dest)*8+7-:8] = ~M_reg_q[(arg1)*8+7-:8];
      end
      5'h0f: begin
        M_reg_d[(dest)*8+7-:8] = M_reg_q[(arg1)*8+7-:8] ^ M_reg_q[(arg2)*8+7-:8];
      end
      5'h12: begin
        if (M_edge_detector0_out) begin
          M_reg_d[(dest)*8+7-:8] = 8'h00;
          M_harddelaycounter_d = 28'h0000000;
        end else begin
          if (M_edge_detector1_out) begin
            M_reg_d[(dest)*8+7-:8] = 8'h01;
            M_harddelaycounter_d = 28'h0000000;
          end else begin
            if (M_difficulty_q & harddelaycounterMSB) begin
              M_reg_d[(dest)*8+7-:8] = 1'h1;
              M_harddelaycounter_d = 28'h0000000;
            end else begin
              M_reg_d[128+7-:8] = M_reg_q[128+7-:8];
              M_harddelaycounter_d = M_harddelaycounter_q + 1'h1;
            end
          end
        end
      end
      5'h10: begin
        if (M_edge_detector0_out) begin
          M_reg_d[(dest)*8+7-:8] = 8'h00;
        end else begin
          if (M_edge_detector1_out) begin
            M_reg_d[(dest)*8+7-:8] = 8'h01;
          end else begin
            M_reg_d[128+7-:8] = M_reg_q[128+7-:8];
          end
        end
      end
      5'h11: begin
        if (M_delaycounter_q[24+0-:1] == 1'h0) begin
          M_delaycounter_d = M_delaycounter_q + 1'h1;
          M_reg_d[128+7-:8] = M_reg_q[128+7-:8];
        end else begin
          M_delaycounter_d = 1'h0;
        end
      end
      5'h13: begin
        M_reg_d[128+7-:8] = M_reg_q[128+7-:8];
      end
      5'h14: begin
        M_question_index_chooser_enable = 1'h1;
        M_reg_d[112+7-:8] = M_question_index_chooser_out;
        M_reg_d[64+7-:8] = M_question_index_chooser_out;
      end
      5'h16: begin
        M_reg_d[(dest)*8+7-:8] = M_reg_q[(arg1)*8+7-:8];
      end
      5'h17: begin
        M_reg_d[(dest)*8+7-:8] = M_effectRom_eff;
        M_effectRom_address = M_reg_q[(arg1)*8+7-:8] * 4'h8 + M_reg_q[(arg2)*8+7-:8] + 1'h1;
      end
      5'h18: begin
        M_reg_d[(dest)*8+0+4-:5] = M_reg_q[(arg1)*8+0+4-:5];
        M_reg_d[(dest)*8+5+2-:3] = 3'h0;
      end
      5'h19: begin
        M_reg_d[128+7-:8] = M_reg_q[(dest)*8+7-:8];
      end
      5'h1a: begin
        lcdWrite = 1'h1;
        if (M_lcddelaycounter_q[12+0-:1]) begin
          M_lcddelaycounter_d = 13'h0000;
        end else begin
          M_reg_d[128+7-:8] = M_reg_q[128+7-:8];
          M_lcddelaycounter_d = M_lcddelaycounter_q + 1'h1;
        end
      end
      5'h1b: begin
        attributeWrite = 1'h1;
      end
      5'h1c: begin
        if (M_qnindexReg_q[(M_reg_q[(arg1)*8+0+5-:6])*1+0-:1] == 1'h1) begin
          M_reg_d[(dest)*8+7-:8] = 8'h01;
        end else begin
          M_reg_d[(dest)*8+7-:8] = 8'h00;
        end
      end
      5'h1d: begin
        M_qnindexReg_d[(M_reg_q[64+7-:8])*1+0-:1] = 1'h1;
      end
      5'h1e: begin
        M_qnindexReg_d = 50'h0000000000000;
      end
      5'h01: begin
        M_difficulty_d = 1'h0;
      end
      5'h1f: begin
        M_difficulty_d = 1'h1;
      end
      5'h02: begin
        M_question_index_chooser_enable = 1'h1;
        M_reg_d[(dest)*8+2+5-:6] = 6'h00;
        M_reg_d[(dest)*8+0+1-:2] = M_question_index_chooser_out[0+1-:2];
      end
    endcase
  end
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_reg_q <= 1'h0;
      M_delaycounter_q <= 1'h0;
      M_harddelaycounter_q <= 1'h0;
      M_qnindexReg_q <= 1'h0;
      M_difficulty_q <= 1'h0;
      M_lcddelaycounter_q <= 1'h0;
    end else begin
      M_reg_q <= M_reg_d;
      M_delaycounter_q <= M_delaycounter_d;
      M_harddelaycounter_q <= M_harddelaycounter_d;
      M_qnindexReg_q <= M_qnindexReg_d;
      M_difficulty_q <= M_difficulty_d;
      M_lcddelaycounter_q <= M_lcddelaycounter_d;
    end
  end
  
endmodule
